#' @title get_interpolated_color_bins
#'
#' @description Return binned abundance data for plotting interpolated values with greater contrast. This is a wrapper around
#' the \link[classInt:classIntervals]{classInt::classIntervals} function to make it easier to return binned color values.
#' @param z a vector of abundance values
#' @param n_bins the number of bins you'd like to return; default is 9
#' @param style the algorithm used in binning; default is 'kmeans', which generally does well with our data
#' @param nice_labels return label values in linear (vs log) space that are formatted for use on plots; this is meant to be #' used in conjunction with values generated by \code{get_interpolated_plot_vals}, which return log10 units.
#'
#' @examples
#'
#' prediction_values = rnorm(100, mean = 1e5, sd = 1e4)
#'
#' #bin data using default values (only z is required)
#' prediction_bins = get_interpolated_color_bins(z = prediction_values)
#'
#' #or experiment with other bins
#' prediction_bins = get_interpolated_color_bins(z = prediction_values, n_bins = 5)
#'
#' #any algorithm used by \code{classInt::classIntervals} can be used if kmeans isn't working for you:
#' prediction_bins = get_interpolated_color_bins(z = prediction_values, n_bins = 5, style = 'jenks')
#'
#' @author Mike Levine
#' @export
get_interpolated_color_bins = function(z,
                               n_bins = 9,
                               style = 'kmeans',
                               nice_labels = TRUE){

  #for reproducibility
  set.seed(129)
  breaks_list = classInt::classIntervals(round(z, digits = 2), n = n_bins, style = 'kmeans', warnLargeN = FALSE)

  #return nicer labels if requested
  if(!is.null(nice_labels) & nice_labels == TRUE){

    #get the low/high values at each position
    lows = c()
    highs = c()
    for (i in 1:(length(breaks_list$brks)-1)){

      lows = rbind(lows, breaks_list$brks[i])
      highs = rbind(highs, breaks_list$brks[i + 1])

    }

    #combine as a dataframe
    lims = data.frame('lows' = lows,
                      'highs' = highs)

    #convert to linear space + round
    lims$lows = trimws(format(10^lims$lows, scientific = FALSE, digits = 1, big.mark = ','))
    lims$highs = trimws(format(10^lims$highs, scientific = FALSE, digits = 1, big.mark = ','))


    #combine labels
    lims$label = paste0(lims$lows, '-', lims$highs)

    #edit the lowermost and uppermost bins to be '<', '>'
    lims$label[1] = paste0('< ', stringr::str_split(lims$label[1], '-')[[1]][[2]])
    lims$label[nrow(lims)] = paste0('> ', stringr::str_split(lims$label[nrow(lims)], '-')[[1]][[1]])

    #map the breaks onto the data
    plot_val = cut(round(z, digits = 2),
                   breaks = breaks_list$brks, include.lowest = TRUE, right = TRUE, labels = lims$label)

  }

  if (is.null(nice_labels)){

  #map the breaks onto the data
  plot_val = cut(round(z, digits = 2),
                 breaks = breaks_list$brks, include.lowest = TRUE, right = TRUE)

  }

  #return the breaks
  return(plot_val)

}
