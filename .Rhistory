build_sf_sticks(x = c(1,2,3), y = c(2,4,6), z =c(8,9,10), group_variable = c('a', 'a', 'b'))
build_sf_sticks(x = c(1,NA,3), y = c(2,3,4), z =c(8,9,10), group_variable = c('a', 'a', 'b'))
build_sf_sticks = function(x,y,z, group_variable = NULL, rotation = 5, bar_scale = 0.5, crs = NULL){
#check inputs: stop if issues
stick_inputs = function(x,y,z, group_variable = NULL){
#x,y,z must be numeric
if (!is.numeric(c(x,y,z))) stop('x,y, and z must all be numeric')
#x, y,z, and, if provided, group_variable must have the same number of observations
if (!is.null(group_variable)){
if (!all(sapply(list(length(x), length(y), length(z), length(group_variable)),
FUN = identical, length(x))))
stop("x, y, z and group variable must be vectors of the same length.")
}
if (is.null(group_variable)){
if (!all(sapply(list(length(x), length(y), length(z)),
FUN = identical, length(x))))
stop("x, y, and z must be vectors of the same length.")
}
}
#verify inputs
stick_inputs(x, y ,z, group_variable)
#make sure the crs, if provided, is in the list of available CRS
#gather the vectors of start positions into a dataframe
plot_pos = data.frame('start_x' = x, 'start_y' = y, 'z' = z)
#remove any rows with NA's too
plot_pos = plot_pos[complete.cases(plot_pos),]
#report any removed rows
removed_rows = plot_pos[!(complete.cases(plot_pos)),]
if (nrow(removed_rows) > 0) warning(paste(nrow(removed_rows), 'rows removed due to NAs'))
#set a scaling factor - we want the tallest bar to be ~30% of the total plot height
total_plot_height = abs(max(plot_pos$start_y) - min(plot_pos$start_y))
max_bar_height = total_plot_height * bar_scale
scaling_factor = max(plot_pos$z)/max_bar_height
#get the 'ends' of the bars as:
#x = same as start_x and y = start_y + scaling factor
plot_pos$end_x = plot_pos$start_x
plot_pos$end_y = plot_pos$start_y + (plot_pos$z/scaling_factor)
#to rotate first convert degrees to radians
rot_rad = rotation * pi/180
#calculate rotated x and y end points
plot_pos$rot_x = (cos(rot_rad) * (plot_pos$end_x - plot_pos$start_x)) +
(sin(rot_rad) * (plot_pos$end_y - plot_pos$start_y)) + plot_pos$start_x
plot_pos$rot_y = (sin(rot_rad) * (plot_pos$end_x - plot_pos$start_x)) +
(cos(rot_rad) * (plot_pos$end_y - plot_pos$start_y)) + plot_pos$start_y
#create sf linestrings
plot_lines = plot_pos%>%
#paste all the starting and ending lats/longs into one string
dplyr::mutate(start_pos = paste0(.data$start_x,' ', .data$start_y),
end_pos = paste0(.data$rot_x,' ', .data$rot_y),
pos_num = seq(1:length(.data$start_pos)))%>%
#organize by starting position, ending position
tidyr::pivot_longer(cols = c(.data$start_pos, .data$end_pos),
names_to = 'type', values_to = 'loc')%>%
#convert text coordinates back to individual numeric columns
dplyr::group_by(.data$pos_num)%>%
tidyr::separate(.data$loc, c("LONG", "LAT"), sep = " ") %>%
dplyr::mutate(dplyr::across(c(.data$LONG, .data$LAT), as.numeric)) %>%
#convert to sf points
sf::st_as_sf(coords = c("LONG", "LAT")) %>%
#connect the points as linestrings for each datapoint- in this case, each position
dplyr::group_by(.data$pos_num) %>%
dplyr::summarize() %>%
sf::st_cast("LINESTRING")%>%
dplyr::select(-.data$pos_num)
#assign crs as needed
if (! is.null(crs)){
#set the crs on the bars for lat/long (i.e. WGS84)
sf::st_crs(plot_lines) = sf::st_crs("EPSG:4326")
#and deal with the transformation to Albers Alaska equal area
plot_lines =  sf::st_transform(plot_lines, crs = 3338)
}
#if the user requested a grouping variable, also add this back in
if (!is.null(group_variable)){
colname = deparse(substitute(group_variable))
if (stringr::str_detect(colname, '\\$')){
colname = stringr::str_split(colname, '\\$')[[1]][2]
}
plot_lines[[colname]] = group_variable
}
#return this dataframe
return(plot_lines)
}
build_sf_sticks(x = c(1,'2',3), y = c(2,3,4), z =c(8,9,10))
build_sf_sticks(x = c(1,2,3), y = c(2,3), z =c(8,9,10))
build_sf_sticks(x = c(1,2,3), y = c(2,4), z =c(8,9,10), group_variable = c('a', 'a', 'b'))
build_sf_sticks(x = c(1,2,3), y = c(2,3,4), z =c(8,9,10))
build_sf_sticks(x = c(1,2,3), y = c(2,4,6), z =c(8,9,10), group_variable = c('a', 'a', 'b'))
build_sf_sticks(x = c(1,NA,3), y = c(2,3,4), z =c(8,9,10), group_variable = c('a', 'a', 'b'))
x = c(1,NA,3)
y = c(2,3,4)
z =c(8,9,10)
group_variable = c('a', 'a', 'b')
#x,y,z must be numeric
if (!is.numeric(c(x,y,z))) stop('x,y, and z must all be numeric')
#check inputs: stop if issues
stick_inputs = function(x,y,z, group_variable = NULL){
#x,y,z must be numeric
if (!is.numeric(c(x,y,z))) stop('x,y, and z must all be numeric')
#x, y,z, and, if provided, group_variable must have the same number of observations
if (!is.null(group_variable)){
if (!all(sapply(list(length(x), length(y), length(z), length(group_variable)),
FUN = identical, length(x))))
stop("x, y, z and group variable must be vectors of the same length.")
}
if (is.null(group_variable)){
if (!all(sapply(list(length(x), length(y), length(z)),
FUN = identical, length(x))))
stop("x, y, and z must be vectors of the same length.")
}
}
#verify inputs
stick_inputs(x, y ,z, group_variable)
#gather the vectors of start positions into a dataframe
plot_pos = data.frame('start_x' = x, 'start_y' = y, 'z' = z)
#remove any rows with NA's too
plot_pos = plot_pos[complete.cases(plot_pos),]
#report any removed rows
removed_rows = plot_pos[!(complete.cases(plot_pos)),]
if (nrow(removed_rows) > 0) warning(paste(nrow(removed_rows), 'rows removed due to NAs'))
nrow(removed_rows)
#remove any rows with NA's too
plot_pos = plot_pos[complete.cases(plot_pos),]
#gather the vectors of start positions into a dataframe
plot_pos = data.frame('start_x' = x, 'start_y' = y, 'z' = z)
#remove any rows with NA's too
plot_pos = plot_pos[complete.cases(plot_pos),]
#gather the vectors of start positions into a dataframe
plot_pos_df = data.frame('start_x' = x, 'start_y' = y, 'z' = z)
#remove any rows with NA's too
plot_pos = plot_pos[complete.cases(plot_pos),]
#gather the vectors of start positions into a dataframe
plot_pos_df = data.frame('start_x' = x, 'start_y' = y, 'z' = z)
#remove any rows with NA's too
plot_pos = plot_pos_df[complete.cases(plot_pos_df),]
#report any removed rows
removed_rows = plot_pos_df[!(complete.cases(plot_pos_df)),]
if (nrow(removed_rows) > 0) warning(paste(nrow(removed_rows), 'rows removed due to NAs'))
@export
#' #sticks are automatically scaled so that the largest abundance value
#' #this can be modified with bar_scale argument
#' sticks =  build_sf_sticks(x = dat$x, y = dat$y, z = dat$z, rotation = -5, bar_scale = 2)
#' sticks2 = build_sf_sticks(x = dat$x, y = dat$y, z = dat$z, rotation = 5, bar_scale = .5)
#'
#' ggplot() +
#'  geom_sf(data = sticks)+
#'  geom_sf(data = sticks2)
#'
#' @export
build_sf_sticks = function(x,y,z, group_variable = NULL, rotation = 5, bar_scale = 0.5, crs = NULL){
#check inputs: stop if issues
stick_inputs = function(x,y,z, group_variable = NULL){
#x,y,z must be numeric
if (!is.numeric(c(x,y,z))) stop('x,y, and z must all be numeric')
#x, y,z, and, if provided, group_variable must have the same number of observations
if (!is.null(group_variable)){
if (!all(sapply(list(length(x), length(y), length(z), length(group_variable)),
FUN = identical, length(x))))
stop("x, y, z and group variable must be vectors of the same length.")
}
if (is.null(group_variable)){
if (!all(sapply(list(length(x), length(y), length(z)),
FUN = identical, length(x))))
stop("x, y, and z must be vectors of the same length.")
}
}
#verify inputs
stick_inputs(x, y ,z, group_variable)
#make sure the crs, if provided, is in the list of available CRS
#gather the vectors of start positions into a dataframe
plot_pos_df = data.frame('start_x' = x, 'start_y' = y, 'z' = z)
#remove any rows with NA's too
plot_pos = plot_pos_df[complete.cases(plot_pos_df),]
#report any removed rows
removed_rows = plot_pos_df[!(complete.cases(plot_pos_df)),]
if (nrow(removed_rows) > 0) warning(paste(nrow(removed_rows), 'rows removed due to NAs'))
#set a scaling factor - we want the tallest bar to be ~30% of the total plot height
total_plot_height = abs(max(plot_pos$start_y) - min(plot_pos$start_y))
max_bar_height = total_plot_height * bar_scale
scaling_factor = max(plot_pos$z)/max_bar_height
#get the 'ends' of the bars as:
#x = same as start_x and y = start_y + scaling factor
plot_pos$end_x = plot_pos$start_x
plot_pos$end_y = plot_pos$start_y + (plot_pos$z/scaling_factor)
#to rotate first convert degrees to radians
rot_rad = rotation * pi/180
#calculate rotated x and y end points
plot_pos$rot_x = (cos(rot_rad) * (plot_pos$end_x - plot_pos$start_x)) +
(sin(rot_rad) * (plot_pos$end_y - plot_pos$start_y)) + plot_pos$start_x
plot_pos$rot_y = (sin(rot_rad) * (plot_pos$end_x - plot_pos$start_x)) +
(cos(rot_rad) * (plot_pos$end_y - plot_pos$start_y)) + plot_pos$start_y
#create sf linestrings
plot_lines = plot_pos%>%
#paste all the starting and ending lats/longs into one string
dplyr::mutate(start_pos = paste0(.data$start_x,' ', .data$start_y),
end_pos = paste0(.data$rot_x,' ', .data$rot_y),
pos_num = seq(1:length(.data$start_pos)))%>%
#organize by starting position, ending position
tidyr::pivot_longer(cols = c(.data$start_pos, .data$end_pos),
names_to = 'type', values_to = 'loc')%>%
#convert text coordinates back to individual numeric columns
dplyr::group_by(.data$pos_num)%>%
tidyr::separate(.data$loc, c("LONG", "LAT"), sep = " ") %>%
dplyr::mutate(dplyr::across(c(.data$LONG, .data$LAT), as.numeric)) %>%
#convert to sf points
sf::st_as_sf(coords = c("LONG", "LAT")) %>%
#connect the points as linestrings for each datapoint- in this case, each position
dplyr::group_by(.data$pos_num) %>%
dplyr::summarize() %>%
sf::st_cast("LINESTRING")%>%
dplyr::select(-.data$pos_num)
#assign crs as needed
if (! is.null(crs)){
#set the crs on the bars for lat/long (i.e. WGS84)
sf::st_crs(plot_lines) = sf::st_crs("EPSG:4326")
#and deal with the transformation to Albers Alaska equal area
plot_lines =  sf::st_transform(plot_lines, crs = 3338)
}
#if the user requested a grouping variable, also add this back in
if (!is.null(group_variable)){
colname = deparse(substitute(group_variable))
if (stringr::str_detect(colname, '\\$')){
colname = stringr::str_split(colname, '\\$')[[1]][2]
}
plot_lines[[colname]] = group_variable
}
#return this dataframe
return(plot_lines)
}
build_sf_sticks(x = c(1,'2',3), y = c(2,3,4), z =c(8,9,10))
build_sf_sticks(x = c(1,2,3), y = c(2,3), z =c(8,9,10))
build_sf_sticks(x = c(1,2,3), y = c(2,4), z =c(8,9,10), group_variable = c('a', 'a', 'b'))
build_sf_sticks(x = c(1,2,3), y = c(2,3,4), z =c(8,9,10))
build_sf_sticks(x = c(1,2,3), y = c(2,4,6), z =c(8,9,10), group_variable = c('a', 'a', 'b'))
build_sf_sticks(x = c(1,NA,3), y = c(2,3,4), z =c(8,9,10), group_variable = c('a', 'a', 'b'))
x = c(1,NA,3)
y = c(2,3,4)
z =c(8,9,10)
group_variable = c('a', 'a', 'b')
!is.null(group_variable)
deparse(substitute(group_variable))
x = c(1,NA,3)
y = c(2,3,4)
z =c(8,9,10)
group_variable = c('a', 'a', 'b')
#check inputs: stop if issues
stick_inputs = function(x,y,z, group_variable = NULL){
#x,y,z must be numeric
if (!is.numeric(c(x,y,z))) stop('x,y, and z must all be numeric')
#x, y,z, and, if provided, group_variable must have the same number of observations
if (!is.null(group_variable)){
if (!all(sapply(list(length(x), length(y), length(z), length(group_variable)),
FUN = identical, length(x))))
stop("x, y, z and group variable must be vectors of the same length.")
}
if (is.null(group_variable)){
if (!all(sapply(list(length(x), length(y), length(z)),
FUN = identical, length(x))))
stop("x, y, and z must be vectors of the same length.")
}
}
#verify inputs
stick_inputs(x, y ,z, group_variable)
#gather the vectors of start positions into a dataframe
if (is.null(group_variable)){
plot_pos_df = data.frame('start_x' = x, 'start_y' = y, 'z' = z)
}
if (!is.null(group_variable)){
plot_pos_df = data.frame('start_x' = x, 'start_y' = y, 'z' = z, 'group_variable' = group_variable)
}
View(plot_pos_df)
#remove any rows with NA's too
plot_pos = plot_pos_df[complete.cases(plot_pos_df),]
#report any removed rows
removed_rows = plot_pos_df[!(complete.cases(plot_pos_df)),]
if (nrow(removed_rows) > 0) warning(paste(nrow(removed_rows), 'rows removed due to NAs'))
if (nrow(removed_rows) > 0) warning(paste(nrow(removed_rows), 'row(s) removed due to NAs'))
#set a scaling factor - we want the tallest bar to be ~30% of the total plot height
total_plot_height = abs(max(plot_pos$start_y) - min(plot_pos$start_y))
max_bar_height = total_plot_height * bar_scale
scaling_factor = max(plot_pos$z)/max_bar_height
#get the 'ends' of the bars as:
#x = same as start_x and y = start_y + scaling factor
plot_pos$end_x = plot_pos$start_x
plot_pos$end_y = plot_pos$start_y + (plot_pos$z/scaling_factor)
#to rotate first convert degrees to radians
rot_rad = rotation * pi/180
#calculate rotated x and y end points
plot_pos$rot_x = (cos(rot_rad) * (plot_pos$end_x - plot_pos$start_x)) +
(sin(rot_rad) * (plot_pos$end_y - plot_pos$start_y)) + plot_pos$start_x
build_sf_sticks = function(x,y,z, group_variable = NULL, rotation = 5, bar_scale = 0.5, crs = NULL){
#check inputs: stop if issues
stick_inputs = function(x,y,z, group_variable = NULL){
#x,y,z must be numeric
if (!is.numeric(c(x,y,z))) stop('x,y, and z must all be numeric')
#x, y,z, and, if provided, group_variable must have the same number of observations
if (!is.null(group_variable)){
if (!all(sapply(list(length(x), length(y), length(z), length(group_variable)),
FUN = identical, length(x))))
stop("x, y, z and group variable must be vectors of the same length.")
}
if (is.null(group_variable)){
if (!all(sapply(list(length(x), length(y), length(z)),
FUN = identical, length(x))))
stop("x, y, and z must be vectors of the same length.")
}
}
#verify inputs
stick_inputs(x, y ,z, group_variable)
#make sure the crs, if provided, is in the list of available CRS
#gather the vectors of start positions into a dataframe
if (is.null(group_variable)){
plot_pos_df = data.frame('start_x' = x, 'start_y' = y, 'z' = z)
}
if (!is.null(group_variable)){
plot_pos_df = data.frame('start_x' = x, 'start_y' = y, 'z' = z, 'group_variable' = group_variable)
}
#remove any rows with NA's too
plot_pos = plot_pos_df[complete.cases(plot_pos_df),]
#report any removed rows
removed_rows = plot_pos_df[!(complete.cases(plot_pos_df)),]
if (nrow(removed_rows) > 0) warning(paste(nrow(removed_rows), 'row(s) removed due to NAs'))
#set a scaling factor - we want the tallest bar to be ~30% of the total plot height
total_plot_height = abs(max(plot_pos$start_y) - min(plot_pos$start_y))
max_bar_height = total_plot_height * bar_scale
scaling_factor = max(plot_pos$z)/max_bar_height
#get the 'ends' of the bars as:
#x = same as start_x and y = start_y + scaling factor
plot_pos$end_x = plot_pos$start_x
plot_pos$end_y = plot_pos$start_y + (plot_pos$z/scaling_factor)
#to rotate first convert degrees to radians
rot_rad = rotation * pi/180
#calculate rotated x and y end points
plot_pos$rot_x = (cos(rot_rad) * (plot_pos$end_x - plot_pos$start_x)) +
(sin(rot_rad) * (plot_pos$end_y - plot_pos$start_y)) + plot_pos$start_x
plot_pos$rot_y = (sin(rot_rad) * (plot_pos$end_x - plot_pos$start_x)) +
(cos(rot_rad) * (plot_pos$end_y - plot_pos$start_y)) + plot_pos$start_y
#create sf linestrings
plot_lines = plot_pos%>%
#paste all the starting and ending lats/longs into one string
dplyr::mutate(start_pos = paste0(.data$start_x,' ', .data$start_y),
end_pos = paste0(.data$rot_x,' ', .data$rot_y),
pos_num = seq(1:length(.data$start_pos)))%>%
#organize by starting position, ending position
tidyr::pivot_longer(cols = c(.data$start_pos, .data$end_pos),
names_to = 'type', values_to = 'loc')%>%
#convert text coordinates back to individual numeric columns
dplyr::group_by(.data$pos_num)%>%
tidyr::separate(.data$loc, c("LONG", "LAT"), sep = " ") %>%
dplyr::mutate(dplyr::across(c(.data$LONG, .data$LAT), as.numeric)) %>%
#convert to sf points
sf::st_as_sf(coords = c("LONG", "LAT")) %>%
#connect the points as linestrings for each datapoint- in this case, each position
dplyr::group_by(.data$pos_num) %>%
dplyr::summarize() %>%
sf::st_cast("LINESTRING")%>%
dplyr::select(-.data$pos_num)
#assign crs as needed
if (! is.null(crs)){
#set the crs on the bars for lat/long (i.e. WGS84)
sf::st_crs(plot_lines) = sf::st_crs("EPSG:4326")
#and deal with the transformation to Albers Alaska equal area
plot_lines =  sf::st_transform(plot_lines, crs = 3338)
}
#if the user requested a grouping variable, also add this back in
if (!is.null(group_variable)){
colname = deparse(substitute(group_variable))
if (stringr::str_detect(colname, '\\$')){
colname = stringr::str_split(colname, '\\$')[[1]][2]
}
plot_lines[[colname]] = plot_pos_df$group_variable
}
#return this dataframe
return(plot_lines)
}
build_sf_sticks(x = c(1,'2',3), y = c(2,3,4), z =c(8,9,10))
build_sf_sticks(x = c(1,2,3), y = c(2,3), z =c(8,9,10))
build_sf_sticks(x = c(1,2,3), y = c(2,4), z =c(8,9,10), group_variable = c('a', 'a', 'b'))
build_sf_sticks(x = c(1,2,3), y = c(2,3,4), z =c(8,9,10))
build_sf_sticks(x = c(1,2,3), y = c(2,4,6), z =c(8,9,10), group_variable = c('a', 'a', 'b'))
build_sf_sticks(x = c(1,NA,3), y = c(2,3,4), z =c(8,9,10), group_variable = c('a', 'a', 'b'))
View(plot_pos_df)
build_sf_sticks = function(x,y,z, group_variable = NULL, rotation = 5, bar_scale = 0.5, crs = NULL){
#check inputs: stop if issues
stick_inputs = function(x,y,z, group_variable = NULL){
#x,y,z must be numeric
if (!is.numeric(c(x,y,z))) stop('x,y, and z must all be numeric')
#x, y,z, and, if provided, group_variable must have the same number of observations
if (!is.null(group_variable)){
if (!all(sapply(list(length(x), length(y), length(z), length(group_variable)),
FUN = identical, length(x))))
stop("x, y, z and group variable must be vectors of the same length.")
}
if (is.null(group_variable)){
if (!all(sapply(list(length(x), length(y), length(z)),
FUN = identical, length(x))))
stop("x, y, and z must be vectors of the same length.")
}
}
#verify inputs
stick_inputs(x, y ,z, group_variable)
#make sure the crs, if provided, is in the list of available CRS
#gather the vectors of start positions into a dataframe
if (is.null(group_variable)){
plot_pos_df = data.frame('start_x' = x, 'start_y' = y, 'z' = z)
}
if (!is.null(group_variable)){
plot_pos_df = data.frame('start_x' = x, 'start_y' = y, 'z' = z, 'group_variable' = group_variable)
}
#remove any rows with NA's too
plot_pos = plot_pos_df[complete.cases(plot_pos_df),]
#report any removed rows
removed_rows = plot_pos_df[!(complete.cases(plot_pos_df)),]
if (nrow(removed_rows) > 0) warning(paste(nrow(removed_rows), 'row(s) removed due to NAs'))
#set a scaling factor - we want the tallest bar to be ~30% of the total plot height
total_plot_height = abs(max(plot_pos$start_y) - min(plot_pos$start_y))
max_bar_height = total_plot_height * bar_scale
scaling_factor = max(plot_pos$z)/max_bar_height
#get the 'ends' of the bars as:
#x = same as start_x and y = start_y + scaling factor
plot_pos$end_x = plot_pos$start_x
plot_pos$end_y = plot_pos$start_y + (plot_pos$z/scaling_factor)
#to rotate first convert degrees to radians
rot_rad = rotation * pi/180
#calculate rotated x and y end points
plot_pos$rot_x = (cos(rot_rad) * (plot_pos$end_x - plot_pos$start_x)) +
(sin(rot_rad) * (plot_pos$end_y - plot_pos$start_y)) + plot_pos$start_x
plot_pos$rot_y = (sin(rot_rad) * (plot_pos$end_x - plot_pos$start_x)) +
(cos(rot_rad) * (plot_pos$end_y - plot_pos$start_y)) + plot_pos$start_y
#create sf linestrings
plot_lines = plot_pos%>%
#paste all the starting and ending lats/longs into one string
dplyr::mutate(start_pos = paste0(.data$start_x,' ', .data$start_y),
end_pos = paste0(.data$rot_x,' ', .data$rot_y),
pos_num = seq(1:length(.data$start_pos)))%>%
#organize by starting position, ending position
tidyr::pivot_longer(cols = c(.data$start_pos, .data$end_pos),
names_to = 'type', values_to = 'loc')%>%
#convert text coordinates back to individual numeric columns
dplyr::group_by(.data$pos_num)%>%
tidyr::separate(.data$loc, c("LONG", "LAT"), sep = " ") %>%
dplyr::mutate(dplyr::across(c(.data$LONG, .data$LAT), as.numeric)) %>%
#convert to sf points
sf::st_as_sf(coords = c("LONG", "LAT")) %>%
#connect the points as linestrings for each datapoint- in this case, each position
dplyr::group_by(.data$pos_num) %>%
dplyr::summarize() %>%
sf::st_cast("LINESTRING")%>%
dplyr::select(-.data$pos_num)
#assign crs as needed
if (! is.null(crs)){
#set the crs on the bars for lat/long (i.e. WGS84)
sf::st_crs(plot_lines) = sf::st_crs("EPSG:4326")
#and deal with the transformation to Albers Alaska equal area
plot_lines =  sf::st_transform(plot_lines, crs = 3338)
}
#if the user requested a grouping variable, also add this back in
if (!is.null(group_variable)){
colname = deparse(substitute(group_variable))
if (stringr::str_detect(colname, '\\$')){
colname = stringr::str_split(colname, '\\$')[[1]][2]
}
plot_lines[[colname]] = plot_pos$group_variable
}
#return this dataframe
return(plot_lines)
}
build_sf_sticks(x = c(1,2,3), y = c(2,4), z =c(8,9,10), group_variable = c('a', 'a', 'b'))
build_sf_sticks(x = c(1,2,3), y = c(2,3,4), z =c(8,9,10))
build_sf_sticks(x = c(1,2,3), y = c(2,4,6), z =c(8,9,10), group_variable = c('a', 'a', 'b'))
build_sf_sticks(x = c(1,NA,3), y = c(2,3,4), z =c(8,9,10), group_variable = c('a', 'a', 'b'))
usethis::use_testthat()
library(MACEReports)
build_sf_sticks(x = c(1,NA,3), y = c(2,3,4), z =c(8,9,10), group_variable = c('a', 'a', 'b'))
testthat::use_test()
use_test()
usethis::use_test()
devtools::test()
devtools::test()
devtools::test()
testthat::test_that("errors", {
testthat::expect_error(
build_sf_sticks(x = c(1,'2',3), y = c(2,3,4), z =c(8,9,10)),
"p cannot be less than 0"
)
})
help("expect_error")
library(MACEReports)
devtools::test()
rm(list = c("build_sf_sticks"))
devtools::test()
build_sf_sticks(x = c(1,NA,3), y = c(2,3,4), z =c(8,9,10), group_variable = c('a', 'a', 'b'))
devtools::test()
build_sf_sticks(x = c(1,NA,3), y = c(2,3,4), z =c(8,9,10), group_variable = c('a', 'a', 'b'))
devtools::test()
build_sf_sticks(x = c(1,NA,3), y = c(2,3,4), z =c(8,9,10), group_variable = c('a', 'a', 'b'))
build_sf_sticks(x = c(1,2,3), y = c(2,3), z =c(8,9,10))
build_sf_sticks(x = c(1,NA,3), y = c(2,3,4), z =c(8,9,10), group_variable = c('a', 'a', 'b'))
devtools::test()
devtools::test()
library(MACEReports)
build_sf_sticks(x = c(1,2,3), y = c(2,4), z =c(8,9,10), group_variable = c('a', 'a', 'b'))
devtools::test()
devtools::test()
library(MACEReports)
?build_sf_sticks
?build_sf_sticks
library(MACEReports)
library(MACEReports)
install.packages("pkgdown")
usethis::use_pkgdown()
library(MACEReports)
pkgdown::build_site()
